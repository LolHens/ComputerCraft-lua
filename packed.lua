-- unpack
-- by LolHens

tArgs = {...}

-- constants
packed = {
 {1, "."},
 {2, "coords", "-5", "-1", "0", "0"},
 {1, "api"},
 {2, "api/mine", "-- mine", "-- by LolHens", "", "-- constants", "slot_dump = 1", "slot_ignore = 2", "minFuelLevel = 10000", "", "digList = {}", "digList[\"x\"] = {}", "digList[\"y\"] = {}", "digList[\"z\"] = {}", "digList[\"r\"] = {}", "", "local function sizeDigTask()", " local i = 1", " while digList[\"x\"][i] ~= nil do", "  i = i + 1", " end", " return i - 1", "end", "", "local function pushDigTask(x, y, z, r)", " local i = 1", " while digList[\"x\"][i] ~= nil do", "  if digList[\"x\"][i]==x and digList[\"y\"][i]==y and digList[\"z\"][i]==z then", "   if digList[\"r\"][i]==nil then digList[\"r\"][i]=r end", "   return", "  end", "  i = i + 1", " end", " digList[\"x\"][i] = x", " digList[\"y\"][i] = y", " digList[\"z\"][i] = z", " digList[\"r\"][i] = r", "end", "", "local function popDigTask()", " local i = sizeDigTask()", " local x, y, z, r = digList[\"x\"][i], digList[\"y\"][i], digList[\"z\"][i], digList[\"r\"][i]", " digList[\"x\"][i] = nil", " return x, y, z, r", "end", "", "function init()", " move.setRefuelHandler(refuel)", " slot_ignore_max = slot_ignore", " for i = slot_ignore, 16, 1 do", "  if turtle.getItemCount(i) > 0 then", "   slot_ignore_max = i", "  end", " end", " slot_items = slot_ignore_max + 1", "end", "", "function refuel()", " repeat", "  for i = slot_items, 16, 1 do", "   turtle.select(i)", "   turtle.refuel(64)", "  end", "  sleep(0.2)", " until turtle.getFuelLevel() > 1", "end", "", "function dumpItems()", " if turtle.getFuelLevel() <= minFuelLevel then refuel() end", " turtle.select(slot_dump)", " move.placeUp(true)", " repeat", "  for i = slot_items, 16, 1 do", "   turtle.select(i)", "   turtle.dropUp()", "  end", " until not shouldDump()", " turtle.select(slot_dump)", " move.digUp()", "end", "", "function shouldDump()", " for slot = slot_items, 16, 1 do", "  if turtle.getItemCount(slot) == 0 then return false end", " end", " return true", "end", "", "function dumpIfNeeded()", " if shouldDump() then dumpItems() end", "end", "", "function isOre(dir)", " if dir==nil then dir=\"\" end", " if not move.getAction(\"detect\", dir)() then return false end", " for i = slot_ignore, slot_ignore_max, 1 do", "  turtle.select(i)", "  if move.getAction(\"compare\", dir)() then", "   turtle.select(slot_items)", "   return false", "  end", " end", " turtle.select(slot_items)", " return true", "end", "", "function checkAround(back)", " if back==nil then back = false end", " if isOre() then pushDigTask(move.getX() + move.getRotationOffsetX(), move.getY(), move.getZ() + move.getRotationOffsetZ()) end", " if isOre(\"up\") then pushDigTask(move.getX(), move.getY() + 1, move.getZ()) end", " if isOre(\"down\") then pushDigTask(move.getX(), move.getY() - 1, move.getZ()) end", " move.turnLeft()", " if isOre() then pushDigTask(move.getX() + move.getRotationOffsetX(), move.getY(), move.getZ() + move.getRotationOffsetZ()) end", " move.turnRight(2)", " if isOre() then pushDigTask(move.getX() + move.getRotationOffsetX(), move.getY(), move.getZ() + move.getRotationOffsetZ()) end", " if back then", "  move.turnRight()", "  if isOre() then pushDigTask(move.getX() + move.getRotationOffsetX(), move.getY(), move.getZ() + move.getRotationOffsetZ()) end", "  move.turnLeft()", " end", " move.turnLeft()", "end", "", "function dig(count, up)", " if count == nil then count = 1 end", " local ret = false", " for i = 1, count, 1 do", "  if up == nil then up = true end", "  pushDigTask(move.getX() + move.getRotationOffsetX(), move.getY(), move.getZ() + move.getRotationOffsetZ(), move.getRotation())", "  local x, y, z, r", "  local check = true", "  y = move.getY()", "  while true do", "   if check and sizeDigTask()>0 then checkAround(move.getY() ~= y) end", "   x, y, z, r = popDigTask()", "   if x==nil then break end", "   dumpIfNeeded()", "   turtle.select(slot_items)", "   check = move.goTo(x, y, z, r, true, true, false, true)", "  end", "  if up then move.digUp() end", " end", " return ret", "end", "", "function getSlotDump()", " return slot_dump", "end", "", "function getSlotIgnore()", " return slot_ignore", "end", "", "function getSlotIgnoreMax()", " return slot_ignore_max", "end", "", "function getSlotItems()", " return slot_items", "end", "", "function getMinFuelLevel()", " return minFuelLevel", "end"},
 {2, "api/move", "-- move", "-- by LolHens", "", "-- global vars", "x = 0", "y = 0", "z = 0", "r = 0", "", "-- locals", "local function save()", " file = io.open(\"coords\", \"w\")", " file:write(x..\"\\n\")", " file:write(y..\"\\n\")", " file:write(z..\"\\n\")", " file:write(r..\"\\n\")", " file:flush()", " file:close()", "end", " ", "local function load()", " if not fs.exists(\"coords\") then", "  return", " end", " file = io.open(\"coords\", \"r\")", " x = tonumber(file:read(\"*l\"))", " y = tonumber(file:read(\"*l\"))", " z = tonumber(file:read(\"*l\"))", " r = tonumber(file:read(\"*l\"))", " file:close()", "end", "", "local function getRotationFor(arg_x, arg_z, alternate)", " if alternate == nil then alternate = false end", " if (not alternate and math.abs(arg_x) > math.abs(arg_z)) or (alternate and math.abs(arg_x) <= math.abs(arg_z)) then", "  arg_x = arg_x / math.abs(arg_x)", "  arg_z = 0", " else", "  arg_z = arg_z / math.abs(arg_z)", "  arg_x = 0", " end", " if arg_x==0 and arg_z>0 then return 0 end", " if arg_x<0 and arg_z==0 then return 1 end", " if arg_x==0 and arg_z<0 then return 2 end", " if arg_x>0 and arg_z==0 then return 3 end", " return 0", "end", "", "local function getRawAction(action, dir)", " if dir==nil then dir=\"\" end", " if dir==\"\" then", "  if action==\"detect\" then", "   return turtle.detect, false", "  elseif action==\"compare\" then", "   return turtle.compare, false", "  elseif action==\"drop\" then", "   return turtle.drop, false", "  elseif action==\"suck\" then", "   return turtle.suck, false", "  elseif action==\"place\" then", "   return turtle.place, false", "  elseif action==\"dig\" then", "   return turtle.dig, false", "  elseif action==\"go\" then", "   return turtle.forward, true", "  elseif action==\"attack\" then", "   return turtle.attack, false", "  end", " elseif dir==\"up\" then", "  if action==\"detect\" then", "   return turtle.detectUp, false", "  elseif action==\"compare\" then", "   return turtle.compareUp, false", "  elseif action==\"drop\" then", "   return turtle.dropUp, false", "  elseif action==\"suck\" then", "   return turtle.suckUp, false", "  elseif action==\"place\" then", "   return turtle.placeUp, false", "  elseif action==\"dig\" then", "   return turtle.digUp, false", "  elseif action==\"go\" then", "   return turtle.up, true", "  elseif action==\"attack\" then", "   return turtle.attackUp, false", "  end", " elseif dir==\"down\" then", "  if action==\"detect\" then", "   return turtle.detectDown, false", "  elseif action==\"compare\" then", "   return turtle.compareDown, false", "  elseif action==\"drop\" then", "   return turtle.dropDown, false", "  elseif action==\"suck\" then", "   return turtle.suckDown, false", "  elseif action==\"place\" then", "   return turtle.placeDown, false", "  elseif action==\"dig\" then", "   return turtle.digDown, false", "  elseif action==\"go\" then", "   return turtle.down, true", "  elseif action==\"attack\" then", "   return turtle.attackDown, false", "  end", " end", " return nil", "end", "", "local function forceAction(action, dir, dig, attack, wait)", " if dig == nil then dig = false end", " if attack == nil then attack = true end", " if wait == nil then wait = false end", " actionFunc, fuelNeeded = getRawAction(action, dir)", " if fuelNeeded and not hasFuel() then return false end", " while not actionFunc() do", "  if getRawAction(\"detect\", dir)() then", "   if (not dig or not getRawAction(\"dig\", dir)()) and not wait then", "    return false", "   end", "  else", "   if attack then", "    getRawAction(\"attack\", dir)()", "   elseif not wait then", "    return false", "   end", "  end", "  sleep(0.2)", " end", " return true", "end", "", "-- globals", "function setRefuelHandler(handler)", " moveRefuelHandler = handler", "end", "", "function getRotationOffsetX(arg_r)", " if arg_r==nil then arg_r = r end", " if arg_r==0 then", "  return 0", " elseif arg_r==1 then", "  return -1", " elseif arg_r==2 then", "  return 0", " elseif arg_r==3 then", "  return 1", " end", " return 0", "end", "", "function getRotationOffsetZ(arg_r)", " if arg_r==nil then arg_r = r end", " if arg_r==0 then", "  return 1", " elseif arg_r==1 then", "  return 0", " elseif arg_r==2 then", "  return -1", " elseif arg_r==3 then", "  return 0", " end", " return 0", "end", "", "function getRotationOffset(arg_r)", " return getRotationOffsetX(arg_r), getRotationOffsetZ(arg_r)", "end", "", "function setCoords(arg_x, arg_y, arg_z, arg_r)", " x = arg_x", " y = arg_y", " z = arg_z", " if arg_r ~= nil then r = arg_r end", " save()", "end", "", "function addCoords(arg_x, arg_y, arg_z, arg_r)", " x = x + arg_x", " y = y + arg_y", " z = z + arg_z", " if arg_r ~= nil then r = r + arg_r end", " save()", "end", " ", "function setRotation(arg_r)", " r = arg_r", " save()", "end", "", "function addRotation(arg_r)", " r = r + arg_r", " if r<0 then r = r + 4 end", " if r>3 then r = r - 4 end", " save()", "end", " ", "function getCoords()", " return x, y, z, r", "end", "", "function getX()", " return x", "end", "", "function getY()", " return y", "end", "", "function getZ()", " return z", "end", " ", "function getRotation()", " return r", "end", "", "function isAt(arg_x, arg_y, arg_z)", " if arg_z==nil and arg_y==nil then", "  return arg_x==y", " elseif arg_z==nil then", "  return arg_x==x and arg_y==z", " end", " return arg_x==x and arg_y==y and arg_z==z", "end", "   ", "function go(dig, attack, wait)", " if forceAction(\"go\", \"\", dig, attack, wait) then", "  xAdd, zAdd = getRotationOffset(r)", "  addCoords(xAdd, 0, zAdd)", "  return true", " end", " return false", "end", "", "function up(dig, attack, wait)", " if forceAction(\"go\", \"up\", dig, attack, wait) then", "  addCoords(0, 1, 0)", "  return true", " end", " return false", "end", "", "function down(dig, attack, wait)", " if forceAction(\"go\", \"down\", dig, attack, wait) then", "  addCoords(0, -1, 0)", "  return true", " end", " return false", "end", "", "function place(dig, attack, wait)", " return forceAction(\"place\", \"\", dig, attack, wait)", "end", "", "function placeUp(dig, attack, wait)", " return forceAction(\"place\", \"up\", dig, attack, wait)", "end", "", "function placeDown(dig, attack, wait)", " return forceAction(\"place\", \"down\", dig, attack, wait)", "end", "", "function dig()", " turtle.dig()", "end", "", "function digUp()", " turtle.digUp()", "end", "", "function digDown()", " turtle.digDown()", "end", "", "function getAction(action, dir)", " if dir==nil then dir=\"\" end", " if dir==\"\" then", "  if action==\"detect\" then", "   return turtle.detect, false", "  elseif action==\"compare\" then", "   return turtle.compare, false", "  elseif action==\"drop\" then", "   return turtle.drop, false", "  elseif action==\"suck\" then", "   return turtle.suck, false", "  elseif action==\"place\" then", "   return place, false", "  elseif action==\"dig\" then", "   return dig, false", "  elseif action==\"go\" then", "   return go, true", "  elseif action==\"attack\" then", "   return turtle.attack, false", "  end", " elseif dir==\"up\" then", "  if action==\"detect\" then", "   return turtle.detectUp, false", "  elseif action==\"compare\" then", "   return turtle.compareUp, false", "  elseif action==\"drop\" then", "   return turtle.dropUp, false", "  elseif action==\"suck\" then", "   return turtle.suckUp, false", "  elseif action==\"place\" then", "   return placeUp, false", "  elseif action==\"dig\" then", "   return digUp, false", "  elseif action==\"go\" then", "   return up, true", "  elseif action==\"attack\" then", "   return turtle.attackUp, false", "  end", " elseif dir==\"down\" then", "  if action==\"detect\" then", "   return turtle.detectDown, false", "  elseif action==\"compare\" then", "   return turtle.compareDown, false", "  elseif action==\"drop\" then", "   return turtle.dropDown, false", "  elseif action==\"suck\" then", "   return turtle.suckDown, false", "  elseif action==\"place\" then", "   return placeDown, false", "  elseif action==\"dig\" then", "   return digDown, false", "  elseif action==\"go\" then", "   return down, true", "  elseif action==\"attack\" then", "   return turtle.attackDown, false", "  end", " end", " return nil", "end", "", "function back()", " if not hasFuel() then return false end", " if turtle.back() then", "  xAdd, zAdd = getRotationOffset(r)", "  addCoords(xAdd * -1, 0, zAdd * -1)", "  return true", " end", " return false", "end", "", "function turn(arg_r)", " diff = arg_r - r", " if math.abs(diff)==3 then", " diff = diff / -3", " end", " for i=1,math.abs(diff),1 do", "  if diff>0 then", "   turnRight()", "  else", "   turnLeft()", "  end", " end", "end", "", "function turnRight(count)", " if count == nil then count = 1 end", " for i = 1, count, 1 do", "  turtle.turnRight()", "  addRotation(1)", " end", "end", "", "function turnLeft()", " if count == nil then count = 1 end", " for i = 1, count, 1 do", "  turtle.turnLeft()", "  addRotation(-1)", " end", "end", "", "function hasFuel()", " if turtle.getFuelLevel() <= 1 and moveRefuelHandler ~= nil then", "  moveRefuelHandler()", " end", " if turtle.getFuelLevel() > 1 then", "  return true", " end", " return false", "end", "", "function goStep(arg_x, arg_z, dig, attack, wait, alternate)", " if alternate == nil then alternate = false end", " if arg_x == 0 or arg_z == 0 then alternate = false end", " turn(getRotationFor(arg_x, arg_z, alternate))", " return go(dig, attack, wait)", "end", "", "function goStepY(arg_y, dig, attack, wait)", " if arg_y > 0 then", "  return up(dig, attack, wait)", " elseif arg_y < 0 then", "  return down(dig, attack, wait)", " end", " return true", "end", "", "function goTo(arg_x, arg_y, arg_z, arg_r, dig, attack, wait, straight)", " if arg_z == nil then", "  arg_z = arg_y", "  arg_y = y", " end", " if dig == nil then dig = false end", " if attack == nil then attack = true end", " if wait == nil then wait = true end", " if straight == nil then straight = false end", " local oldY = y", " while not isAt(arg_x, arg_y, arg_z) do", "  if not isAt(arg_x, arg_z) then", "   local alternate = 0", "   local dodge = -1", "   if straight then alternate = 2 end", "   if arg_y >= oldY then dodge = dodge * -1 end", "   while not goStep(arg_x - x, arg_z - z, dig and alternate == 2, attack, false) and not goStep(arg_x - x, arg_z - z, dig and alternate == 2, attack, false, true) do", "    if not goStepY(dodge, dig and alternate == 2, attack, false) then", "	 if alternate == 0 then", "	  alternate = alternate + 1", "	  dodge = dodge * -1", "	 elseif alternate == 1 then", "	  alternate = alternate + 1", "	 elseif alternate >= 2 then", "	  if not wait then", "	   return false", "	  else", "	   alternate = 0", "	   dodge = dodge * -1", "	   if straight then alternate = 2 end", "	  end", "	 end", "	end", "    sleep(0.2)", "   end", "  elseif not isAt(arg_y) then", "   if not goStepY(arg_y - y, true, attack, false) and not wait then return false end", "  end", "  sleep(0.2)", " end", " if arg_r ~= nil then turn(arg_r) end", " return true", "end", "", "load()"},
 {2, "intelliMine", "-- intelliMine", "-- by LolHens", "", "tArgs = {...}", "", "function printInfo()", " print(\"Libraries:   move\")", " print(\"Slot \"..mine.getSlotDump()..\":      Ender Chest\")", " print(\"Slot \"..mine.getSlotIgnore()..\" - \"..mine.getSlotIgnoreMax()..\":  Ignored Blocks\")", " print(\"Slot \"..mine.getSlotItems()..\" - 16: Empty Slots\")", " sleep(2)", "end", "", "function stripmine(count, depth)", " local i = 1", " while i <= count or count == -1 do ", "  i = i + 1", "  move.digUp()", "  mine.dig()", "  move.turnRight(2)", "  mine.dig()", "  move.turnLeft()", "  mine.dig(depth)", "  move.turnLeft()", "  mine.dig(3)", "  move.turnLeft()", "  mine.dig(depth)", "  move.turnLeft()", "  mine.dig()", "  move.turnRight(2)", "  mine.dig(4)", " end", "end", "", "function main()", " count=tonumber(tArgs[1])", " depth=tonumber(tArgs[2])", " if count==nil then count=-1 end", " if depth==nil then depth=30 end", " mine.init()", " printInfo()", " stripmine(count, depth)", "end", "", "main()"},
 {2, "pack", "-- pack", "-- by LolHens", "", "tArgs = {...}", "", "local function pack(path, file_stream, out)", " if fs.isDir(path) then", "  if fs.combine(path, \"/\"):sub(1, 3) ~= \"rom\" then", "   file_stream:write(\" {\")", "   file_stream:write(\"1\")", "   file_stream:write(\", \\\"\"..path..\"\\\"\")", "   file_stream:write(\"},\\n\")", "   for _, file in pairs(fs.list(path)) do", "    pack(fs.combine(path, file), file_stream, out)", "   end", "  end", " else", "  if fs.combine(path, \"/\"):sub(1, 3) ~= \"rom\" and fs.combine(path, \"/\") ~= fs.combine(out, \"/\") then", "   print(path)", "   file_stream:write(\" {\")", "   file_stream:write(\"2\")", "   file_stream:write(\", \\\"\"..path..\"\\\"\")", "   local file = io.open(path, \"r\")", "   local file_line = file:read(\"*l\")", "   while file_line ~= nil do", "    file_line = file_line:gsub(\"(\\\\)\", \"\\\\%0\")", "	file_line = file_line:gsub(\"(\\\")\", \"\\\\%0\")", "    file_stream:write(\", \\\"\"..file_line..\"\\\"\")", "    file_line = file:read(\"*l\")", "   end", "   file:close()", "   file_stream:write(\"},\\n\")", "  end", " end", "end", "", "function main(path, out)", " print(\"Packing \\\"\"..path..\"\\\" into \\\"\"..out..\"\\\"...\")", " local file_stream = io.open(out, \"w\")", " file_stream:write(\"-- unpack\\n-- by LolHens\\n\\n\")", " file_stream:write(\"tArgs = {...}\\n\\n\")", " file_stream:write(\"-- constants\\n\")", " file_stream:write(\"packed = {\\n\")", " pack(path, file_stream, out)", " file_stream:write(\"}\\n\\n\")", " file_stream:write(\"local function doFile(num, out)\\n\")", " file_stream:write(\" local file = packed[num]\\n\")", " file_stream:write(\" local file_type = file[1]\\n\")", " file_stream:write(\" local file_path = out..file[2]\\n\")", " file_stream:write(\" if (file_type == 1) then\\n\")", " file_stream:write(\"  if not fs.exists(file_path) or not fs.isDir(file_path) then\\n\")", " file_stream:write(\"   fs.makeDir(file_path)\\n\")", " file_stream:write(\"  end\\n\")", " file_stream:write(\" elseif (file_type == 2) then\\n\")", " file_stream:write(\"  print(file_path)\\n\")", " file_stream:write(\"  local file_stream = io.open(file_path, \\\"w\\\")\\n\")", " file_stream:write(\"  for i, file_line in pairs(packed[num]) do\\n\")", " file_stream:write(\"   if i > 2 then file_stream:write(file_line..\\\"\\\\n\\\") end\\n\")", " file_stream:write(\"  end\\n\")", " file_stream:write(\"  file_stream:flush()\\n\")", " file_stream:write(\"  file_stream:close()\\n\")", " file_stream:write(\" end\\n\")", " file_stream:write(\"end\\n\\n\")", " file_stream:write(\"function main(out)\\n\")", " file_stream:write(\" if out==nil then\\n\")", " file_stream:write(\"  out=\\\"./\\\"\\n\")", " file_stream:write(\" elseif out:sub(out:len()) ~= \\\"/\\\" then\\n\")", " file_stream:write(\"  out = out..\\\"/\\\"\\n\")", " file_stream:write(\" end\\n\")", " file_stream:write(\" print(\\\"Unpacking to \\\\\\\"\\\"..out..\\\"\\\\\\\"...\\\")\\n\")", " file_stream:write(\" for i in pairs(packed) do\\n\")", " file_stream:write(\"  doFile(i, out)\\n\")", " file_stream:write(\" end\\n\")", " file_stream:write(\"end\\n\\n\")", " file_stream:write(\"main(tArgs[1])\")", " file_stream:flush()", " file_stream:close()", "end", "", "main(tArgs[1], tArgs[2])"},
 {2, "tree", "-- tree", "-- by LolHens", "", "tArgs = {...}", "", "function fellTree(height)", " turtle.select(1)", " if turtle.detect() then", "  move.go(true)", "  num = 1", "  while turtle.compareUp() and (height==nil or num<height) do", "   num = num + 1", "   move.up(true) ", "  end", "  for i=2, num, 1 do", "   move.down()", "  end", " end", "end", "", "function isTree()", " turtle.select(1)", " return turtle.detect() and (turtle.getItemCount(1)==0 or turtle.compare())", "end", "", "function findTree(sub)", " move.turnLeft()", " if isTree() then return true end", " move.turnRight()", " if isTree() then return true end", " move.turnRight()", " if isTree() then return true end", " move.turnRight()", " if isTree() then return true end", " if not sub and not turtle.detect() then", "  move.go()", "  return findTree(true)", " end", " return false", "end", "", "function main(height)", " if height~= nil then height=tonumber(height) end", " if turtle.detect() then fellTree(height) end", " while findTree(false) do", "  fellTree(height)", " end", "end", "", "main(tArgs[1])"},
 {2, "startup", "os.loadAPI(\"api/move\")", "os.loadAPI(\"api/mine\")"},
}

local function doFile(num, out)
 local file = packed[num]
 local file_type = file[1]
 local file_path = out..file[2]
 if (file_type == 1) then
  if not fs.exists(file_path) or not fs.isDir(file_path) then
   fs.makeDir(file_path)
  end
 elseif (file_type == 2) then
  print(file_path)
  local file_stream = io.open(file_path, "w")
  for i, file_line in pairs(packed[num]) do
   if i > 2 then file_stream:write(file_line.."\n") end
  end
  file_stream:flush()
  file_stream:close()
 end
end

function main(out)
 if out==nil then
  out="./"
 elseif out:sub(out:len()) ~= "/" then
  out = out.."/"
 end
 print("Unpacking to \""..out.."\"...")
 for i in pairs(packed) do
  doFile(i, out)
 end
end

main(tArgs[1])